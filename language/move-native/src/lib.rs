//! A Move native runtime prototype.
//!
//! This crate is part of the Solana project to port Move to LLVM and SBF.
//!
//! It contains three types of definitions
//!
//! - Types with layouts known to the compiler for the purposes of calling
//!   runtime functions. These have simple C-ABI layouts.
//! - "Native" library functions required by the Move standard library, calls to
//!   which are generated by the LLVM backend.
//! - Runtime functions specific to the LLVM port as necessary to dynamically
//!   implement Move semantics.
//!
//! As of now this crate is concerned only with implementing Move "natives"
//! required by the Move standard library. The basic strategy is to define
//! simple data types for primitives like scalars and vectors, and runtime types
//! like type descriptors; and naming and calling conventions for translating
//! Move native calls to C-ABI calls. The native implementations convert the
//! Move types to existing Rust types like `Vec` to do their work.
//!
//! It contains several modules dividing the crate by concerns:
//!
//! - `rt_types` defines the types shared between LLVM and the runtime.
//! - `std` defines the native functions called declared by Move `std`.
//! - `conv` defines conversions between Move types and Rust types.
//! - `target_defs` defines Solana-specific definitions that differ from Move VM
//!   or might reasonably differ for non-Solana targets.
//!
//!
//! # Native functions background
//!
//! Native functions in Move are functions that the standard library relies on
//! the runtime to provide. They are declared with the `native` keyword and no
//! implementation. They are similar to `extern` functions in Rust.
//!
//! Here are some examples:
//!
//! ```move
//!    native public fun sha2_256(data: vector<u8>): vector<u8>;
//!
//!    /// Add element `e` to the end of the vector `v`.
//!    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);
//!
//!    /// Pop an element from the end of vector `v`.
//!    /// Aborts if `v` is empty.
//!    native public fun pop_back<Element>(v: &mut vector<Element>): Element;
//!
//!    /// Return the binary representation of `v` in BCS (Binary Canonical Serialization) format
//!    native public fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
//! ```
//!
//! In the Move VM these are implemented in Rust and registered with the VM at
//! runtime. These implementations are tightly tied to VM internals, and include
//! features like gas accounting that are irrelevant for the LLVM port. They are
//! not directly reusable by the LLVM port at this time.
//!
//!
//! # Generics and type interpretation
//!
//! The translation between Move native declarations and the C ABI is relatively
//! straightforward, with conventions described further in this document.
//!
//! The big complication is that many natives are generic, so there are choices
//! to be made about how to interpret type descriptors.
//!
//! This implementation interprets types at runtime by passing a [`MoveType`]
//! reference for every generic type. The `MoveType` definition closely mirrors
//! the Move compiler's `runtime_type::Type` definition.
//!
//! It appears that the native calls mostly need to know about size and
//! alignment of types to implement things like generic vector operations. There
//! are though functions for serialization and debug printing that would appear
//! to require fully interpreting arbitrary Move types. It is not yet clear
//! what challenges this will entail.
//!
//! Embedding full type interpreters into the runtime means that every Move
//! program will contain code for interpreting every possible type, including
//! those it does not need. There may be ways to mitigate this bloat with clever
//! structure and LTO, but it is unclear.
//!
//! The alternative to runtime type interpretation is to have the compiler emit
//! monomorphizations of native calls. This would appear to be a challenging
//! problem, one that might be easiest solved by having the compiler emit Rust
//! code to instantiate generic natives. This approach could be left to a future
//! optimization.
//!
//!
//! # Reusing move crates and `no-std`
//!
//! For portability it could be desirable to not depend on `std`.
//!
//! It may be necessary to reuse existing move crates, which will force this
//! crate to depend on Rust `std`. For Solana this probably won't present a
//! problem as Solana has a mostly-complete port of `std`.
//!
//! Move serialization at least depends ot the [`bcs`] crate, which has relatively
//! few dependencies, but does depend on `std`. It could conceivably be adopted
//! to a `no-std` environment.
//!
//! This crate itself doesn't directly use `std`.
//!
//!
//! # Platform compatibility
//!
//! Some definitions are different on Solana than on Move VM.
//!
//! - An address is 32 bytes to match Solana pubkeys. On Move VM an address is
//!   16 bytes by default but can be configured as 20 or 32 bytes at compile
//!   time.
//!
//!
//! # Naming conventions
//!
//! Within the Move VM natives are identified by a module name plus a function
//! name, like "vector" + "push_back". They do not appear to additionally be
//! identified by a library name like "std".
//!
//! Our native symbol names are a concatenation of the prefix "move_native",
//! plus the module name and function name. So the vector `push_back` function
//! symbol is
//!
//! > `move_native_vector_push_back`
//!
//! In Rust code, native functions are defined under the `std` module, in
//! submodules that mirror the module heirarchy of the Move standard library,
//! and their final symbol names are given through the `export_name` attribute.
//!
//!
//! # Data types
//!
//! Data types known to both the compiler and the runtime are defined in [`rt_types`].
//! They are all declared with explicit `repr` attributes to have a defined layout that
//! is easy to codegen.
//!
//! The most important types for the compiler and the vector type,
//! [`MoveUntypedVector`] here, and the type descriptor, here [`MoveType`].
//!
//! `MoveType` is similar to `move_vm_types::runtime_types::Type`, but with a
//! structure that does not rely on Rust-specific type layout. `MoveType`
//! contains recursive `&'static` references to other `MoveType`s, necessitating
//! that binaries contain a static table of all needed type descriptors.
//!
//! Generic values are represented by references or pointers to [`AnyType`],
//! which is simply a transparent wrapper around a u8, pointers to which must
//! be unsafely casted based on an accompanying `MoveType`.
//!
//! Move references as interpreted by `TypeDesc` are assumed to always be
//! pointers - no fat pointers.
//!
//! The types defined in `rt_types` will change. The exact definitions will
//! depend on decisions made for code generation.
//!
//!
//! # Vectors and strings
//!
//! Move vectors are operated on by casting to Rust vectors and reusing the Rust
//! methods. Move vectors have the same layout as Rust vecs, on the theory this
//! may save a few instructions during conversions.
//!
//! Move strings are a library type and not known to the Move compiler†.
//! They are a wrapper around byte vectors, and native string calls are
//! operations on `MoveByteVector`.
//!
//! Vectors must be allocated with the [`move_native_vec_empty`] and deallocated
//! with the [`move_native_vec_destroy_empty`] runtime calls.
//!
//! † - note that although `String` is a library type, the ASCII `String` (move
//! has UTF-8 and ASCII strings) is exposed to the runtime via the `TypeName`
//! library type, which is passed by value in the [`move_native_type_name_get`]
//! native function, the code generator and the runtime need to agree on its
//! layout.
//!
//!
//! # Calling conventions
//!
//! The calling conventions are straightforword, following the C ABI, with some
//! extra patterns necessary for things like Move type parameters and unsized
//! generic values.
//!
//! - type parameters
//!   - passed as `&MoveType`
//! - by-ref generic types
//!   - passed by `&AnyType`
//! - by-value generic types
//!   - passed by `*mut AnyType`
//!   - examples: `write_to_event_store`
//! - by-value generic return types
//!   - stack-allocated return pointer of `*mut AnyType`
//!   - examples: `pop_back`
//!
//!
//! # References
//!
//! Useful Move code to read.
//!
//! - `move-stdlib::natives`
//! - `move-vm-types::loaded_data::Type`
//! - `move-vm-types::values::Value`
//! - `move-core-types::value`
//!
//!
//! # todo
//!
//! - type constraints
//!   - `write_to_event_store<T: drop + store>`
//! - generic by-value and return arguments might instead be `&mut MaybeUninit<SomeUnsizedPlaceholder>`
//!   - llvm would need to write a fat pointer - do they have defined layout?
//! - should serialization maintain compatibility with move vm?
//! - add context to unwrapped errors

#![allow(unused)]
#![no_std]

extern crate alloc;

/// Types known to the compiler.
pub(crate) mod rt_types {
    use crate::target_defs;

    /// A Move vector with an untyped buffer.
    ///
    /// Used in the API for generic vector arguments.
    ///
    /// The only way to interact with these is to convert them from / to Rust
    /// vectors or references to Rust vectors, with functions in the [`conv`]
    /// module.
    ///
    /// The only way to create and destroy them is with the
    /// [`move_native_vec_empty`] and [`move_native_vec_destroy_empty`] native
    /// calls.
    #[repr(C)]
    pub struct MoveUntypedVector {
        pub ptr: *mut u8,  // safety: must be correctly aligned per type
        pub capacity: u64, // in typed elements, not u8
        pub length: u64,   // in typed elements, not u8
    }

    /// A Move vector of bytes.
    ///
    /// These occur in the API enough to warrant their own type, and there are
    /// dedicated functions to convert them to Rust vectors.
    #[repr(C)]
    pub struct MoveByteVector {
        pub ptr: *mut u8,
        pub capacity: u64,
        pub length: u64,
    }

    /// A Move vector of signers.
    ///
    /// This type occurs in the native API, but it will probably be removed, in
    /// favor of just using `MoveUntypedVector`.
    #[repr(C)]
    pub struct MoveSignerVector {
        pub ptr: *mut MoveSigner,
        pub capacity: u64,
        pub length: u64,
    }

    /// A reification of the Move runtime type description.
    ///
    /// This is structured as a `TypeDesc` indicating which type a thing is,
    /// and an undiscriminated union holding additional information about the
    /// type.
    ///
    /// cc runtime_types::Type
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct MoveType {
        pub type_desc: TypeDesc,
        pub type_info: TypeInfo,
    }

    #[repr(u32)]
    #[derive(Copy, Clone)]
    pub enum TypeDesc {
        Bool = 1,
        U8 = 2,
        U64 = 3,
        U128 = 4,
        Address = 5,
        Signer = 6,
        Vector = 7,
        //Struct = 8,
        //StructInstantiation = 9,
        Reference = 10,
        //MutableReference = 11,
        //TyParam = 12,
    }

    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union TypeInfo {
        pub nothing: u8, // if no type info is needed
        pub vector: VectorTypeInfo,
        pub struct_: u8,              // todo
        pub struct_instantiation: u8, // todo
        pub reference: ReferenceTypeInfo,
        pub mutable_reference: ReferenceTypeInfo,
        pub ty_param: u8, // todo
    }

    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct VectorTypeInfo {
        pub element_type: &'static MoveType,
    }

    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ReferenceTypeInfo {
        pub element_type: &'static MoveType,
    }

    #[repr(transparent)]
    pub struct AnyValue(u8);

    #[repr(transparent)]
    #[derive(Debug)]
    pub struct MoveSigner(pub MoveAddress);

    /// A Move address.
    ///
    /// This is mapped to the address size of the target platform, and may
    /// differ from Move VM.
    #[repr(transparent)]
    #[derive(Debug)]
    pub struct MoveAddress(pub [u8; target_defs::ACCOUNT_ADDRESS_LENGTH]);

    // Defined in std::type_name; not a primitive.
    #[repr(C)]
    pub struct TypeName {
        name: MoveAsciiString,
    }

    // Defined in std::ascii; not a primitive.
    #[repr(C)]
    pub struct MoveAsciiString {
        bytes: MoveByteVector,
    }

    // todo this would be more correct with a lifetime attached
    #[repr(transparent)]
    pub struct MoveUntypedReference(pub *const AnyValue);
}

/// Implementations of native calls.
mod std {
    mod bcs {
        use crate::conv::*;
        use crate::rt_types::*;

        /// Serialize any value.
        ///
        /// This is definitely not correct. Just a first pass.
        ///
        /// # References
        ///
        /// - `move-vm-types::values::Value`
        /// - `move-core-types::value`
        #[export_name = "move_native_bcs_to_bytes"]
        unsafe extern "C" fn to_bytes(type_v: &MoveType, v: &AnyValue) -> MoveByteVector {
            let v = borrow_move_value_as_rust_value(type_v, v);
            let s = bcs::to_bytes(&v).unwrap();
            rust_vec_to_move_byte_vec(s)
        }
    }

    // nursery
    mod debug {
        use crate::conv::*;
        use crate::rt_types::*;
        use crate::target_defs;
        use alloc::format;
        use alloc::string::String;
        use core::fmt::Write;

        #[export_name = "move_native_debug_print"]
        unsafe extern "C" fn print(type_x: &MoveType, x: &AnyValue) {
            let v = borrow_move_value_as_rust_value(type_x, x);
            target_defs::print_string(&format!("{:?}", v));
        }

        #[export_name = "move_native_print_stack_trace"]
        extern "C" fn print_stack_trace() {
            target_defs::print_stack_trace();
        }
    }

    // nursery
    mod event {
        use crate::rt_types::*;

        #[export_name = "move_native_event_write_to_event_store"]
        unsafe extern "C" fn write_to_event_store(
            type_msg: &MoveType,
            guid: MoveByteVector,
            count: u64,
            msg: *mut AnyValue,
        ) {
            todo!()
        }
    }

    mod hash {
        use crate::conv::{move_byte_vec_to_rust_vec, rust_vec_to_move_byte_vec};
        use crate::rt_types::*;
        use sha2::{Digest, Sha256};
        use sha3::Sha3_256;

        #[export_name = "move_native_hash_sha2_256"]
        unsafe extern "C" fn sha2_256(ptr: MoveByteVector) -> MoveByteVector {
            let rust_vec = move_byte_vec_to_rust_vec(ptr);

            let hash_vec = Sha256::digest(rust_vec.as_slice()).to_vec();
            let move_vec = rust_vec_to_move_byte_vec(hash_vec);

            move_vec
        }

        #[export_name = "move_native_hash_sha3_256"]
        unsafe extern "C" fn sha3_256(ptr: MoveByteVector) -> MoveByteVector {
            let rust_vec = move_byte_vec_to_rust_vec(ptr);

            let hash_vec = Sha3_256::digest(rust_vec.as_slice()).to_vec();
            let move_vec = rust_vec_to_move_byte_vec(hash_vec);

            move_vec
        }
    }

    mod signer {
        use crate::rt_types::*;

        #[export_name = "move_native_signer_borrow_address"]
        extern "C" fn borrow_address(s: &MoveSigner) -> &MoveAddress {
            todo!()
        }
    }

    mod string {
        use crate::conv::*;
        use crate::rt_types::*;
        use alloc::vec::Vec;
        use core::str;

        #[export_name = "move_native_string_internal_check_utf8"]
        unsafe extern "C" fn internal_check_utf8(v: &MoveByteVector) -> bool {
            let rust_vec = borrow_move_byte_vec_as_rust_vec(v);
            let res = str::from_utf8(&rust_vec);

            match res {
                Ok(_) => true,
                Err(_) => false,
            }
        }

        #[export_name = "move_native_string_internal_is_char_boundary"]
        unsafe extern "C" fn internel_is_char_boundary(v: &MoveByteVector, i: u64) -> bool {
            let rust_vec = borrow_move_byte_vec_as_rust_vec(v);
            let i = usize::try_from(i).expect("usize");

            let rust_str = str::from_utf8(&rust_vec).expect("invalid utf8");
            rust_str.is_char_boundary(i)
        }

        #[export_name = "move_native_string_internal_sub_string"]
        unsafe extern "C" fn internal_sub_string(
            v: &MoveByteVector,
            i: u64,
            j: u64,
        ) -> MoveByteVector {
            let rust_vec = borrow_move_byte_vec_as_rust_vec(v);
            let i = usize::try_from(i).expect("usize");
            let j = usize::try_from(j).expect("usize");

            let rust_str = str::from_utf8(&rust_vec).expect("invalid utf8");

            let sub_rust_vec = rust_str[i..j].as_bytes().to_vec();
            rust_vec_to_move_byte_vec(sub_rust_vec)
        }

        #[export_name = "move_native_string_internal_index_of"]
        unsafe extern "C" fn internal_index_of(s: &MoveByteVector, r: &MoveByteVector) -> u64 {
            let s_rust_vec = borrow_move_byte_vec_as_rust_vec(s);
            let s_rust_str = str::from_utf8(&s_rust_vec).expect("invalid utf8");
            let r_rust_vec = borrow_move_byte_vec_as_rust_vec(r);
            let r_rust_str = str::from_utf8(&r_rust_vec).expect("invalid utf8");

            let res = s_rust_str.find(r_rust_str);

            u64::try_from(match res {
                Some(i) => i,
                None => s_rust_str.len(),
            })
            .expect("u64")
        }
    }

    mod type_name {
        use crate::rt_types::*;

        #[export_name = "move_native_type_name_get"]
        extern "C" fn get(type_: &MoveType) -> TypeName {
            todo!()
        }
    }

    mod unit_test {
        use crate::rt_types::*;

        #[export_name = "move_native_unit_test_create_signers_for_testing"]
        extern "C" fn create_signers_for_testing(num_signers: u64) -> MoveSignerVector {
            todo!()
        }
    }

    mod vector {
        use crate::conv::*;
        use crate::rt_types::*;
        use alloc::vec::Vec;
        use core::{mem, ptr};

        // safety: Even empty Rust vectors have non-null buffer pointers,
        // which must be correctly aligned. This function crates empty Rust vecs
        // of the correct type and converts them to untyped move vecs.
        #[export_name = "move_native_vector_empty"]
        extern "C" fn empty(type_r: &MoveType) -> MoveUntypedVector {
            let move_vec = match type_r.type_desc {
                TypeDesc::Bool => rust_vec_to_move_vec::<bool>(Vec::new()),
                TypeDesc::U8 => rust_vec_to_move_vec::<u8>(Vec::new()),
                TypeDesc::U64 => rust_vec_to_move_vec::<u64>(Vec::new()),
                TypeDesc::U128 => rust_vec_to_move_vec::<u128>(Vec::new()),
                TypeDesc::Address => rust_vec_to_move_vec::<MoveAddress>(Vec::new()),
                TypeDesc::Signer => rust_vec_to_move_vec::<MoveSigner>(Vec::new()),
                TypeDesc::Vector => {
                    // safety: need correct alignment for the internal vector
                    // pointer of the outer vector, which is non-null even for
                    // an unallocated vector. `MoveUntypedVector` has the same
                    // size and alignment regardless of the type it contains, so
                    // no need to interpret the vector type.
                    rust_vec_to_move_vec::<MoveUntypedVector>(Vec::new())
                }
                TypeDesc::Reference => rust_vec_to_move_vec::<MoveUntypedReference>(Vec::new()),
            };

            move_vec
        }

        #[export_name = "move_native_vector_length"]
        unsafe extern "C" fn length(type_ve: &MoveType, v: &MoveUntypedVector) -> u64 {
            // It is not strictly necessary to convert the vec for this op.
            // Doing it for consistency.
            let rust_vec = borrow_typed_move_vec_as_rust_vec(type_ve, v);

            let len = match rust_vec {
                TypedMoveBorrowedRustVec::Bool(v) => v.len(),
                TypedMoveBorrowedRustVec::U8(v) => v.len(),
                TypedMoveBorrowedRustVec::U64(v) => v.len(),
                TypedMoveBorrowedRustVec::U128(v) => v.len(),
                TypedMoveBorrowedRustVec::Address(v) => v.len(),
                TypedMoveBorrowedRustVec::Signer(v) => v.len(),
                TypedMoveBorrowedRustVec::Vector(_t, v) => v.len(),
                TypedMoveBorrowedRustVec::Reference(_t, v) => v.len(),
            };

            u64::try_from(len).expect("u64")
        }

        #[export_name = "move_native_vector_borrow"]
        unsafe extern "C" fn borrow<'v>(
            type_ve: &MoveType,
            v: &'v MoveUntypedVector,
            i: u64,
        ) -> &'v AnyValue {
            let rust_vec = borrow_typed_move_vec_as_rust_vec(type_ve, v);

            let i = usize::try_from(i).expect("usize");
            let value = match rust_vec {
                TypedMoveBorrowedRustVec::Bool(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::U8(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::U64(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::U128(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Address(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Signer(v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Vector(_t, v) => mem::transmute(&v[i]),
                TypedMoveBorrowedRustVec::Reference(_t, v) => mem::transmute(&v[i]),
            };

            value
        }

        #[rustfmt::skip]
        #[export_name = "move_native_vector_push_back"]
        unsafe extern "C" fn push_back(
            type_ve: &MoveType,
            v: &mut MoveUntypedVector,
            e: *mut AnyValue
        ) {
            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => v.push(ptr::read(e as *const bool)),
                TypedMoveBorrowedRustVecMut::U8(mut v) => v.push(ptr::read(e as *const u8)),
                TypedMoveBorrowedRustVecMut::U64(mut v) => v.push(ptr::read(e as *const u64)),
                TypedMoveBorrowedRustVecMut::U128(mut v) => v.push(ptr::read(e as *const u128)),
                TypedMoveBorrowedRustVecMut::Address(mut v) => v.push(ptr::read(e as *const MoveAddress)),
                TypedMoveBorrowedRustVecMut::Signer(mut v) => v.push(ptr::read(e as *const MoveSigner)),
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => v.push(ptr::read(e as *const MoveUntypedVector)),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => v.push(ptr::read(e as *const MoveUntypedReference)),
            }
        }

        #[rustfmt::skip]
        #[export_name = "move_native_vector_borrow_mut"]
        unsafe extern "C" fn borrow_mut<'v>(
            type_ve: &MoveType,
            v: &'v mut MoveUntypedVector,
            i: u64
        ) -> &'v mut AnyValue {
            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            let i = usize::try_from(i).expect("usize");
            let value = match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::U8(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::U64(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::U128(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Address(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Signer(mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => mem::transmute(&mut v[i]),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => mem::transmute(&mut v[i]),
            };

            value
        }

        #[export_name = "move_native_vector_pop_back"]
        unsafe extern "C" fn pop_back(
            type_ve: &MoveType,
            v: &mut MoveUntypedVector,
            r: *mut AnyValue,
        ) {
            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            let msg = "popping from empty vec";
            match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => {
                    ptr::write(r as *mut bool, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::U8(mut v) => {
                    ptr::write(r as *mut u8, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::U64(mut v) => {
                    ptr::write(r as *mut u64, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::U128(mut v) => {
                    ptr::write(r as *mut u128, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Address(mut v) => {
                    ptr::write(r as *mut MoveAddress, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Signer(mut v) => {
                    ptr::write(r as *mut MoveSigner, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => {
                    ptr::write(r as *mut MoveUntypedVector, v.pop().expect(msg));
                }
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => {
                    ptr::write(r as *mut MoveUntypedReference, v.pop().expect(msg));
                }
            }
        }

        #[export_name = "move_native_vector_destroy_empty"]
        unsafe extern "C" fn destroy_empty(type_ve: &MoveType, v: MoveUntypedVector) {
            assert_eq!(v.length, 0);
            match type_ve.type_desc {
                TypeDesc::Bool => drop(move_vec_to_rust_vec::<bool>(v)),
                TypeDesc::U8 => drop(move_vec_to_rust_vec::<u8>(v)),
                TypeDesc::U64 => drop(move_vec_to_rust_vec::<u64>(v)),
                TypeDesc::U128 => drop(move_vec_to_rust_vec::<u128>(v)),
                TypeDesc::Address => drop(move_vec_to_rust_vec::<MoveAddress>(v)),
                TypeDesc::Signer => drop(move_vec_to_rust_vec::<MoveSigner>(v)),
                TypeDesc::Vector => {
                    // safety: need the correct internal pointer alignment to
                    // deallocate; need the outer vector to be empty to avoid
                    // dropping the inner vectors. As in `empty`,
                    // MoveUntypedVector should have the same size/alignment
                    // regardless of the contained type, so no need to interpret
                    // the vector type.
                    drop(move_vec_to_rust_vec::<MoveUntypedVector>(v))
                }
                TypeDesc::Reference => drop(move_vec_to_rust_vec::<MoveUntypedReference>(v)),
            }
        }

        #[export_name = "move_native_vector_swap"]
        unsafe extern "C" fn swap(type_ve: &MoveType, v: &mut MoveUntypedVector, i: u64, j: u64) {
            let i = usize::try_from(i).expect("usize");
            let j = usize::try_from(j).expect("usize");

            let mut rust_vec = borrow_typed_move_vec_as_rust_vec_mut(type_ve, v);

            match rust_vec {
                TypedMoveBorrowedRustVecMut::Bool(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::U8(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::U64(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::U128(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Address(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Signer(mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Vector(_t, mut v) => v.swap(i, j),
                TypedMoveBorrowedRustVecMut::Reference(_t, mut v) => v.swap(i, j),
            }
        }
    }
}

/// Conversion from move types to rust types.
pub(crate) mod conv {
    use crate::rt_types::*;
    use alloc::vec::Vec;
    use core::marker::PhantomData;
    use core::mem;
    use core::ops::{Deref, DerefMut};
    use core::ptr;

    pub unsafe fn move_byte_vec_to_rust_vec(mv: MoveByteVector) -> Vec<u8> {
        let mv = MoveUntypedVector {
            ptr: mv.ptr,
            capacity: mv.capacity,
            length: mv.length,
        };
        move_vec_to_rust_vec(mv)
    }

    pub fn rust_vec_to_move_byte_vec(rv: Vec<u8>) -> MoveByteVector {
        let mv = rust_vec_to_move_vec(rv);
        MoveByteVector {
            ptr: mv.ptr,
            capacity: mv.capacity,
            length: mv.length,
        }
    }

    pub fn borrow_move_byte_vec_as_rust_vec<'mv>(
        mv: &'mv MoveByteVector,
    ) -> MoveBorrowedRustVec<'mv, u8> {
        assert_eq!(
            mem::size_of::<MoveByteVector>(),
            mem::size_of::<MoveUntypedVector>()
        );
        assert_eq!(
            mem::align_of::<MoveByteVector>(),
            mem::align_of::<MoveUntypedVector>()
        );
        // safety: both repr(c) with same layout, probably ok
        let mv: &'mv MoveUntypedVector = unsafe { mem::transmute(mv) };
        unsafe { borrow_move_vec_as_rust_vec(mv) }
    }

    pub unsafe fn move_vec_to_rust_vec<T>(mv: MoveUntypedVector) -> Vec<T> {
        let rv = Vec::from_raw_parts(
            mv.ptr as *mut T,
            usize::try_from(mv.length).expect("overflow"),
            usize::try_from(mv.capacity).expect("overflow"),
        );
        rv
    }

    pub fn rust_vec_to_move_vec<T>(mut rv: Vec<T>) -> MoveUntypedVector {
        let mv = MoveUntypedVector {
            ptr: rv.as_mut_ptr() as *mut u8,
            capacity: u64::try_from(rv.capacity()).expect("overflow"),
            length: u64::try_from(rv.len()).expect("overflow"),
        };
        mem::forget(rv);
        mv
    }

    pub unsafe fn borrow_move_vec_as_rust_vec<'mv, T>(
        mv: &'mv MoveUntypedVector,
    ) -> MoveBorrowedRustVec<'mv, T> {
        let rv = Vec::from_raw_parts(
            mv.ptr as *mut T,
            usize::try_from(mv.length).expect("overflow"),
            usize::try_from(mv.capacity).expect("overflow"),
        );
        MoveBorrowedRustVec {
            inner: rv,
            _lifetime: PhantomData,
        }
    }

    pub unsafe fn borrow_move_vec_as_rust_vec_mut<'mv, T>(
        mv: &'mv mut MoveUntypedVector,
    ) -> MoveBorrowedRustVecMut<'mv, T> {
        let rv = Vec::from_raw_parts(
            mv.ptr as *mut T,
            usize::try_from(mv.length).expect("overflow"),
            usize::try_from(mv.capacity).expect("overflow"),
        );
        MoveBorrowedRustVecMut {
            inner: rv,
            _lifetime: PhantomData,
        }
    }

    pub struct MoveBorrowedRustVec<'mv, T> {
        inner: Vec<T>,
        _lifetime: PhantomData<&'mv ()>,
    }

    pub struct MoveBorrowedRustVecMut<'mv, T> {
        inner: Vec<T>,
        _lifetime: PhantomData<&'mv ()>,
    }

    impl<'mv, T> Drop for MoveBorrowedRustVec<'mv, T> {
        fn drop(&mut self) {
            let rv = mem::replace(&mut self.inner, Vec::new());
            mem::forget(rv);
        }
    }

    impl<'mv, T> Drop for MoveBorrowedRustVecMut<'mv, T> {
        fn drop(&mut self) {
            let rv = mem::replace(&mut self.inner, Vec::new());
            mem::forget(rv);
        }
    }

    impl<'mv, T> Deref for MoveBorrowedRustVec<'mv, T> {
        type Target = Vec<T>;

        fn deref(&self) -> &Self::Target {
            &self.inner
        }
    }

    impl<'mv, T> Deref for MoveBorrowedRustVecMut<'mv, T> {
        type Target = Vec<T>;

        fn deref(&self) -> &Self::Target {
            &self.inner
        }
    }

    impl<'mv, T> DerefMut for MoveBorrowedRustVecMut<'mv, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.inner
        }
    }

    pub enum TypedMoveValue {
        Bool(bool),
        U8(u8),
        U64(u64),
        U128(u128),
        Address(MoveAddress),
        Signer(MoveSigner),
        Vector(MoveType, MoveUntypedVector),
        // todo
        Reference(MoveType, MoveUntypedReference),
        // todo
    }

    pub unsafe fn take_move_value_as_rust_value(
        type_: &MoveType,
        value: *mut AnyValue,
    ) -> TypedMoveValue {
        match type_.type_desc {
            TypeDesc::Bool => TypedMoveValue::Bool(ptr::read(value as *mut bool)),
            TypeDesc::U8 => TypedMoveValue::U8(ptr::read(value as *mut u8)),
            TypeDesc::U64 => TypedMoveValue::U64(ptr::read(value as *mut u64)),
            TypeDesc::U128 => TypedMoveValue::U128(ptr::read(value as *mut u128)),
            TypeDesc::Address => TypedMoveValue::Address(ptr::read(value as *mut MoveAddress)),
            TypeDesc::Signer => TypedMoveValue::Signer(ptr::read(value as *mut MoveSigner)),
            TypeDesc::Vector => {
                let element_type = *type_.type_info.vector.element_type;
                let move_val = ptr::read(value as *mut MoveUntypedVector);
                TypedMoveValue::Vector(element_type, move_val)
            }
            TypeDesc::Reference => {
                let element_type = *type_.type_info.reference.element_type;
                let move_val = ptr::read(value as *mut MoveUntypedReference);
                TypedMoveValue::Reference(element_type, move_val)
            }
        }
    }

    pub unsafe fn give_rust_value_as_move_value(value: TypedMoveValue, place: *mut AnyValue) {
        match value {
            TypedMoveValue::Bool(v) => {
                ptr::write(place as *mut bool, v);
            }
            TypedMoveValue::U8(v) => {
                ptr::write(place as *mut u8, v);
            }
            TypedMoveValue::U64(v) => {
                ptr::write(place as *mut u64, v);
            }
            TypedMoveValue::U128(v) => {
                ptr::write(place as *mut u128, v);
            }
            TypedMoveValue::Address(v) => {
                ptr::write(place as *mut MoveAddress, v);
            }
            TypedMoveValue::Signer(v) => {
                ptr::write(place as *mut MoveSigner, v);
            }
            TypedMoveValue::Vector(_t, v) => {
                ptr::write(place as *mut MoveUntypedVector, v);
            }
            TypedMoveValue::Reference(_t, v) => {
                ptr::write(place as *mut MoveUntypedReference, v);
            }
        }
    }

    pub enum BorrowedTypedMoveValue<'mv> {
        Bool(&'mv bool),
        U8(&'mv u8),
        U64(&'mv u64),
        U128(&'mv u128),
        Address(&'mv MoveAddress),
        Signer(&'mv MoveSigner),
        Vector(MoveType, &'mv MoveUntypedVector),
        // todo
        Reference(MoveType, &'mv MoveUntypedReference),
        // todo
    }

    pub unsafe fn borrow_move_value_as_rust_value<'mv>(
        type_: &MoveType,
        value: &'mv AnyValue,
    ) -> BorrowedTypedMoveValue<'mv> {
        // todo need to think about the soundness of this transmute
        match type_.type_desc {
            TypeDesc::Bool => BorrowedTypedMoveValue::Bool(mem::transmute(value)),
            TypeDesc::U8 => BorrowedTypedMoveValue::U8(mem::transmute(value)),
            TypeDesc::U64 => BorrowedTypedMoveValue::U64(mem::transmute(value)),
            TypeDesc::U128 => BorrowedTypedMoveValue::U128(mem::transmute(value)),
            TypeDesc::Address => BorrowedTypedMoveValue::Address(mem::transmute(value)),
            TypeDesc::Signer => BorrowedTypedMoveValue::Signer(mem::transmute(value)),
            TypeDesc::Vector => {
                let element_type = *type_.type_info.vector.element_type;
                let move_ref = mem::transmute(value);
                BorrowedTypedMoveValue::Vector(element_type, move_ref)
            }
            TypeDesc::Reference => {
                let element_type = *type_.type_info.reference.element_type;
                let move_ref = mem::transmute(value);
                BorrowedTypedMoveValue::Reference(element_type, move_ref)
            }
        }
    }

    pub enum TypedMoveBorrowedRustVec<'mv> {
        Bool(MoveBorrowedRustVec<'mv, bool>),
        U8(MoveBorrowedRustVec<'mv, u8>),
        U64(MoveBorrowedRustVec<'mv, u64>),
        U128(MoveBorrowedRustVec<'mv, u128>),
        Address(MoveBorrowedRustVec<'mv, MoveAddress>),
        Signer(MoveBorrowedRustVec<'mv, MoveSigner>),
        Vector(MoveType, MoveBorrowedRustVec<'mv, MoveUntypedVector>),
        // todo
        Reference(MoveType, MoveBorrowedRustVec<'mv, MoveUntypedReference>),
        // todo
    }

    pub enum TypedMoveBorrowedRustVecMut<'mv> {
        Bool(MoveBorrowedRustVecMut<'mv, bool>),
        U8(MoveBorrowedRustVecMut<'mv, u8>),
        U64(MoveBorrowedRustVecMut<'mv, u64>),
        U128(MoveBorrowedRustVecMut<'mv, u128>),
        Address(MoveBorrowedRustVecMut<'mv, MoveAddress>),
        Signer(MoveBorrowedRustVecMut<'mv, MoveSigner>),
        Vector(MoveType, MoveBorrowedRustVecMut<'mv, MoveUntypedVector>),
        // todo
        Reference(MoveType, MoveBorrowedRustVecMut<'mv, MoveUntypedReference>),
        // todo
    }

    #[rustfmt::skip]
    pub unsafe fn borrow_typed_move_vec_as_rust_vec<'mv>(
        type_: &MoveType,
        mv: &'mv MoveUntypedVector,
    ) -> TypedMoveBorrowedRustVec<'mv> {
        match type_.type_desc {
            TypeDesc::Bool => {
                TypedMoveBorrowedRustVec::Bool(borrow_move_vec_as_rust_vec::<bool>(mv))
            }
            TypeDesc::U8 => {
                TypedMoveBorrowedRustVec::U8(borrow_move_vec_as_rust_vec::<u8>(mv))
            }
            TypeDesc::U64 => {
                TypedMoveBorrowedRustVec::U64(borrow_move_vec_as_rust_vec::<u64>(mv))
            }
            TypeDesc::U128 => {
                TypedMoveBorrowedRustVec::U128(borrow_move_vec_as_rust_vec::<u128>(mv))
            }
            TypeDesc::Address => {
                TypedMoveBorrowedRustVec::Address(borrow_move_vec_as_rust_vec::<MoveAddress>(mv))
            }
            TypeDesc::Signer => {
                TypedMoveBorrowedRustVec::Signer(borrow_move_vec_as_rust_vec::<MoveSigner>(mv))
            }
            TypeDesc::Vector => {
                TypedMoveBorrowedRustVec::Vector(
                    *type_.type_info.vector.element_type,
                    borrow_move_vec_as_rust_vec::<MoveUntypedVector>(mv),
                )
            }
            TypeDesc::Reference => {
                TypedMoveBorrowedRustVec::Reference(
                    *type_.type_info.reference.element_type,
                    borrow_move_vec_as_rust_vec::<MoveUntypedReference>(mv),
                )
            }
        }
    }

    #[rustfmt::skip]
    pub unsafe fn borrow_typed_move_vec_as_rust_vec_mut<'mv>(
        type_: &MoveType,
        mv: &'mv mut MoveUntypedVector,
    ) -> TypedMoveBorrowedRustVecMut<'mv> {
        match type_.type_desc {
            TypeDesc::Bool => {
                TypedMoveBorrowedRustVecMut::Bool(borrow_move_vec_as_rust_vec_mut::<bool>(mv))
            }
            TypeDesc::U8 => {
                TypedMoveBorrowedRustVecMut::U8(borrow_move_vec_as_rust_vec_mut::<u8>(mv))
            }
            TypeDesc::U64 => {
                TypedMoveBorrowedRustVecMut::U64(borrow_move_vec_as_rust_vec_mut::<u64>(mv))
            }
            TypeDesc::U128 => {
                TypedMoveBorrowedRustVecMut::U128(borrow_move_vec_as_rust_vec_mut::<u128>(mv))
            }
            TypeDesc::Address => {
                TypedMoveBorrowedRustVecMut::Address(borrow_move_vec_as_rust_vec_mut::<MoveAddress>(mv))
            }
            TypeDesc::Signer => {
                TypedMoveBorrowedRustVecMut::Signer(borrow_move_vec_as_rust_vec_mut::<MoveSigner>(mv))
            }
            TypeDesc::Vector => {
                TypedMoveBorrowedRustVecMut::Vector(
                    *type_.type_info.vector.element_type,
                    borrow_move_vec_as_rust_vec_mut::<MoveUntypedVector>(mv),
                )
            }
            TypeDesc::Reference => {
                TypedMoveBorrowedRustVecMut::Reference(
                    *type_.type_info.reference.element_type,
                    borrow_move_vec_as_rust_vec_mut::<MoveUntypedReference>(mv),
                )
            }
        }
    }

    /// # References
    ///
    /// - `move-vm-types::values::Value`
    /// - `move-core-types::value`
    impl<'mv> serde::Serialize for BorrowedTypedMoveValue<'mv> {
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            match self {
                BorrowedTypedMoveValue::Bool(v) => serializer.serialize_bool(**v),
                BorrowedTypedMoveValue::U8(v) => serializer.serialize_u8(**v),
                BorrowedTypedMoveValue::U64(v) => serializer.serialize_u64(**v),
                BorrowedTypedMoveValue::U128(v) => serializer.serialize_u128(**v),
                BorrowedTypedMoveValue::Address(v) => v.0.serialize(serializer),
                BorrowedTypedMoveValue::Signer(v) => v.0 .0.serialize(serializer),
                BorrowedTypedMoveValue::Vector(mt, mv) => unsafe {
                    let rv = borrow_typed_move_vec_as_rust_vec(mt, mv);
                    rv.serialize(serializer)
                },
                BorrowedTypedMoveValue::Reference(mt, mv) => unsafe {
                    let rv = borrow_move_value_as_rust_value(mt, &*mv.0);
                    rv.serialize(serializer)
                },
            }
        }
    }

    impl<'mv> serde::Serialize for TypedMoveBorrowedRustVec<'mv> {
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;

            match self {
                TypedMoveBorrowedRustVec::Bool(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::U8(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::U64(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::U128(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(e)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Address(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(&e.0)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Signer(v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        seq.serialize_element(&e.0 .0)?;
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Vector(t, v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_typed_move_vec_as_rust_vec(t, e);
                            seq.serialize_element(&e)?;
                        }
                    }
                    seq.end()
                }
                TypedMoveBorrowedRustVec::Reference(t, v) => {
                    let mut seq = serializer.serialize_seq(Some(v.len()))?;
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_move_value_as_rust_value(t, &*e.0);
                            seq.serialize_element(&e)?;
                        }
                    }
                    seq.end()
                }
            }
        }
    }

    impl<'mv> core::fmt::Debug for BorrowedTypedMoveValue<'mv> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                BorrowedTypedMoveValue::Bool(v) => v.fmt(f),
                BorrowedTypedMoveValue::U8(v) => v.fmt(f),
                BorrowedTypedMoveValue::U64(v) => v.fmt(f),
                BorrowedTypedMoveValue::U128(v) => v.fmt(f),
                BorrowedTypedMoveValue::Address(v) => v.fmt(f),
                BorrowedTypedMoveValue::Signer(v) => v.fmt(f),
                BorrowedTypedMoveValue::Vector(t, v) => unsafe {
                    let rv = borrow_typed_move_vec_as_rust_vec(t, v);
                    rv.fmt(f)
                },
                BorrowedTypedMoveValue::Reference(t, v) => unsafe {
                    let rv = borrow_move_value_as_rust_value(t, &*v.0);
                    rv.fmt(f)
                },
            }
        }
    }

    impl<'mv> core::fmt::Debug for TypedMoveBorrowedRustVec<'mv> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                TypedMoveBorrowedRustVec::Bool(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::U8(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::U64(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::U128(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::Address(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::Signer(v) => v.fmt(f),
                TypedMoveBorrowedRustVec::Vector(t, v) => {
                    let mut dbg = f.debug_list();
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_typed_move_vec_as_rust_vec(t, e);
                            dbg.entry(&e);
                        }
                    }
                    dbg.finish()
                }
                TypedMoveBorrowedRustVec::Reference(t, v) => {
                    let mut dbg = f.debug_list();
                    for e in v.iter() {
                        unsafe {
                            let e = borrow_move_value_as_rust_value(t, &*e.0);
                            dbg.entry(&e);
                        }
                    }
                    dbg.finish()
                }
            }
        }
    }
}

/// Compatibility with the target platform, e.g. Solana.
pub(crate) mod target_defs {
    // Solana pubkeys are 32 bytes.
    // Move addresses are 16 bytes by default, but can be made 20 or 32 at compile time.
    pub const ACCOUNT_ADDRESS_LENGTH: usize = 32;

    pub fn print_string(s: &str) {
        todo!()
    }

    pub fn print_stack_trace() {
        todo!()
    }
}
